% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_parser.R
\name{.make_parser}
\alias{.make_parser}
\title{Build a typed OKX JSON response parser (named or positional) → data.table}
\usage{
.make_parser(schema, mode = c("named", "positional"))
}
\arguments{
\item{schema}{A \code{data.frame} describing the response fields with columns:
\describe{
  \item{\code{okx}}{Field name in the raw JSON response (used as output column names).}
  \item{\code{formal}}{Human-readable label (stored in \code{attr(, "var_labels")}).}
  \item{\code{type}}{One of \code{"time"}, \code{"numeric"}, \code{"integer"},
    \code{"string"}, \code{"logical"}.}
}}

\item{mode}{Parsing mode; either \code{"named"} (default) for key-based access,
or \code{"positional"} for index-based access.}
}
\value{
A function with signature \code{function(res, tz)} where:
  \describe{
    \item{\code{res}}{An \code{httr::response}. The body must decode to a list
      with \code{$code}, \code{$msg}, and \code{$data}.}
    \item{\code{tz}}{Timezone string used for \code{"time"} fields. Millisecond
      timestamps are converted via \code{as.POSIXct(ms/1000, tz=tz)}.}
  }
  The returned parser yields a \code{data.table} with column names from
  \code{schema$okx} and attaches variable labels as
  \code{attr(DT, "var_labels")} (a named character vector \code{formal} by \code{okx}).
  Returns \code{NULL} if the API \code{code} is not \code{"0"} or if \code{$data}
  is empty.
}
\description{
Constructs and returns a parser function that converts an OKX REST API JSON
response into a typed \code{data.table}, using a provided field schema and a
parsing \code{mode}. Supports both key-based (\code{"named"}) and index-based
(\code{"positional"}) endpoints. For \code{"named"} endpoints returning a
single object, the parser wraps it as a one-row table.
}
\details{
\itemize{
  \item \strong{Typing}: Columns are preallocated per \code{schema$type}. Time fields
  are interpreted as UNIX \emph{milliseconds}.
  \item \strong{Modes}:
    \itemize{
      \item \code{"named"} — fields accessed via \code{okx} keys; a single object
        in \code{$data} is wrapped to one row.
      \item \code{"positional"} — fields accessed by index order of \code{schema}.
    }
  \item \strong{Attributes}: \code{attr(DT, "var_labels")} maps \code{okx} → \code{formal}.
}
}
\section{Errors & warnings}{

If \code{parsed$code != "0"}, a warning with \code{parsed$msg} is emitted and
\code{NULL} is returned.
}

\examples{
\dontrun{
# Suppose `schema` has columns: okx, formal, type; and `res` is an httr response.
parser <- .make_parser(schema, mode = "named")
DT <- parser(res, tz = "UTC")
if (!is.null(DT)) {
  str(DT)
  attr(DT, "var_labels")
}
}

}
\keyword{internal}
